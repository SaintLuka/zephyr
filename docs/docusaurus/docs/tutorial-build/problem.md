---
sidebar_position: 3
---

# Создание задачи

## Постановка задачи

Смоделируем колебание мембраны, края которой закреплены по прямоугольнику.  Колебания мембраны описывает двумерное волновое уравнение:
```
u_{tt} = a^2 \Delta u = a^2 (u_{xx} + u_{yy}).
```
Для моделирования используем явную трёхслойную схему.
```
\frac{u^{n + 1}_i - 2 u^{n}_i + u^{n - 1}_i}{\Delta t^2} = \frac{a^2}{V_i} \sum_{j} \frac{u^{n}_j - u^{n}_i}{|r_j - r_i|} S_{ij},
```
которая записана методом конечных объемов. Здесь `\Delta t` - временной шаг, `V_i` -- объем ячейки, `S_{ij}` -- площадь грани ячейки,
`r_i` -- центр ячейки. Схема подходит для моделирования уравнения на произвольных сетках.
Для устойчивости схемы требуется выполнение условия Куранта: `\Delta t \le \min(\Delta x, \Delta y) / (2 a)`. *Это приближенное условие*.

## Добавление цели

Добавим задачу в папку `problems`. Создадим файл `wave.cpp`,  в файле `problems/CMakeLists.txt` добавим строку
```
list(APPEND PROBLEMS wave)
```
Для сборки цели `wave` необходимо убедиться, что включена опция `ZEPHYR_ENABLE_PROBLEMS`.
В этом случае цель wave появится в выдаче cmake в списке компилируемых задач.
Перейдем к написанию файла `wave.cpp`.

## Файл с кодом типа

### Подключение основных модулей

Для начала включаем основные заголовочные файлы
```
#include <zephyr/geom/generator/rectangle.h>
#include <zephyr/mesh/euler/eu_mesh.h>
#include <zephyr/io/pvd_file.h>
```
Файл `generator/rectangle.h` включает сеточный генератор,
`euler/eu_mesh.h` содержит класс для работы с эйлеровыми сетками,
`io/pvd_file.h` содержит функции для сохранения расчетных данных.
Далее разрешим использовать все пространства имен.
```
using namespace zephyr::geom;
using namespace zephyr::mesh;
using namespace zephyr::io;
using generator::Rectangle;
```

### Создание сетки

Начнем программу с создания сеточного генератора `Rectangle`.
```
int main() {
    Rectangle gen(-2.0, 1.0, -2.0, 1.0);
    gen.set_nx(400);
    gen.set_boundaries({.left=Boundary::WALL, .right=Boundary::WALL,
                        .bottom=Boundary::WALL, .top=Boundary::WALL});
```
Генератор `Rectangle` в качестве аргументов принимает границы области по осям,
в нашем случае это границы квадрата $[-2, 1] \times [-2, 1]$.
Последним аргументом можно передать `true`, тогда будет построена неструктурированная
сетка из ячеек Вороного. В следующей строке выставляется число ячеек по оси $x$.
Разбиение по оси $y$ выбирается автоматически, чтобы получились квадратные (по возможности) ячейки.
В последней строке задаются граничные условия на границах области. Флаги граничных условий:
- `Boundary::UNDEFINED` – пропускает грань *(по умолчанию)*;
- `Boundary::ORDINARY` – внутренняя грань между двумя ячейками;`
- `Boundary::WALL` – отражающие граничные условия (стенка);
- `Boundary::ZOE` – повторяет внутреннюю ячейку (zero order extrapolation);
- `Boundary::PERIODIC` – периодические граничные условия.

В нашем случае (для закрепленной мембраны) опция `Boundary::WALL` является целесообразной.
В любом случае флаги граничных условий не обрабатываются автоматически, обработку граничных
условий требуется писать в решателе.

Далее создаем расчетную сетку `EuMesh` и добавляем расчетные поля.
```
    EuMesh mesh(gen);

    Storable<double> u_prev = mesh.add<double>("u_prev");
    Storable<double> u_curr = mesh.add<double>("u_curr");
    Storable<double> u_next = mesh.add<double>("u_next");
```
Схема является трёхслойной, поэтому достаточно хранить на сетке три параметра
`u_prev` – предыдущий временной слой, `u_curr` – текущий, `u_next` – следующий.
На сетку можно добавлять не только `double`, но и произвольные пользовательские
структуры без наследования и с тривиальным конструктором.

Для добавления полей данных к ячейкам сетки используется синтаксис:
```
Storable<T> key = mesh.add<T>(name);
```
В данном случае на сетку добавляется поле типа `T` с именем `name`.  Ключ `key` понадобится
в дальнейшем для доступа к данным на сетке. Ключ почти ничего не весит,
`sizeof(Storable<T>) = sizeof(int)`, поэтому его всегда можно передавать по значению, а также
свободно копировать.

### Запись в файл

Создадим экземпляр `PvdFile` для последовательного сохранения данных расчета
```
    PvdFile pvd("wave", "output");
    pvd.variables.append("u", u_curr);
```
В данном случае "output" – название директории, "wave" – название файла без расширения.
Итоговый файл будет иметь название "wave.pvd". В переменные для записи добавлен ключ
`u_curr` под именем "u". Pvd формат это простой текстовый файл, который можно открыть
любым текстовым редактором. Pvd файл содержит последовательность имён файлов, которые
уже непосредственно хранят результаты.

### Задание начальных условий

Выставим начальные условия:
```
    for (auto cell: mesh) {
        double r = cell.center().norm();
        cell[u_prev] = 0.5 + 0.5 * std::tanh(50 * (0.5 - r));
        cell[u_curr] = cell[u_prev];
    }
```
Для обхода ячеек сетки доступен range-based цикл. Чтобы получить центр ячейки используется
функция `cell.center()`, последующий вызов `.norm()` возвращает радиус центра ячейки.
Доступ к полям ячейки выполняется через ключи `u_prev`, `u_curr` и `operator[]`.

Выполним следующий проход по сетке, чтобы определить шаг интегрирования по времени.
```
    double speed = 1.0;
    double dt = std::numeric_limits<double>::max();
    for (auto cell: mesh) {
        dt = std::min(dt, 0.5 * cell.incircle_diameter() / speed);
    }
    dt *= 0.95; // Условие Куранта
```
Из интересных деталей в коде – функция `cell.incircle_diameter()`, она позволяет определить диаметр вписанной в ячейку окружности.
Другие функции ячеек можно найти в классе `EuCell`.

### Основной цикл программы

Перейдем к основному циклу программы. Каждые 10 шагов будем делать вывод в консоль и сохранение
в файл.
```
    size_t n_step = 0;
    double curr_time = dt;
    while (curr_time < 5.0 && n_step < 5000) {
        if (n_step % 10 == 0) {
            std::cout << "Step: " << n_step << ";\tTime: " << curr_time << "\n";
            pvd.save(mesh, curr_time);
        }
```

В основном цикле по ячейкам необходимо посчитать значения `u_next` в соответствии
с численной схемой.
```
        for (auto cell: mesh) {
            double uc = cell[u_curr];

            double sum = 0.0;
            for (auto face: cell.faces()) {
                double un = face.neib(u_curr);
                if (face.is_boundary()) {
                    un = -uc;
                }

                double dr = (face.center() - cell.center()).norm();
                sum += (un - uc) * face.area() / (2.0 * dr);
            }

            cell[u_next] = 2.0 * cell[u_curr] - cell[u_prev] +
                std::pow(speed * dt, 2) * sum / cell.volume();
        }
```
Как видим, для обхода по граням ячейки также есть range-based цикл. Все функции, которые
есть у граней, можно найти в документации к классу `EuFace`. Наиболее важные функции:
- `face.normal()` – внешняя нормаль грани;
- `face.area()` – площадь (длина) грани;
- `face.is_boundary()` – граничное условие?
- `face.flag()` – флаг граничных условий;
- `face.neib()` – возвращает соседнюю ячейку через грань;
- `face.neib(Storable<T> key)` – данные соседней ячейки, эквивалентно вызову
  `face.neib()[key]`.

Получение соседней ячейки `face.neib()` через грань всегда валидно, если соседа не существует
(к примеру для ячеек на границе), тогда возвращается сама ячейка. Аналогично для функции
`face.neib(Storable<T>)`, если соседа не существует, то мы получим данные самой ячейки.

В коде также используются геометрические функции `face.center()`, `cell.center()`, `cell.volume()`.
Получаем из текущей ячейки значение `uc`, из соседней ячейки `un`. Если грань на границе
(`face.is_boundary()`), то в качестве `un` используем отраженное значение `uc`.

После вычисления новых значений `u_next` для всех ячеек можно сместить временные слои:
`u_curr` $\to$ `u_prev`, `u_next` $\to$ `u_curr`.
```
        for (auto cell: mesh) {
            cell[u_prev] = cell[u_curr];
            cell[u_curr] = cell[u_next];
        }
```

В конце цикла необходимо обновить переменные: номер шага `n_step` и текущее расчетное время
`curr_time`. После цикла можно сделать последнее сохранение и завершить выполнение.
```
        curr_time += dt;
        ++n_step;
    } // конец основного цикла
    pvd.save(mesh, curr_time);
    return 0;
} // конец main
```

Большинство конечно-объемных решателей устроены и реализованы подобным образом. Основные
возможности, не рассмотренные в данном разделе: работа с геометрией, параллельные вычисления
с MPI, многопоточное выполнение, использование локально-адаптивных сеток.

